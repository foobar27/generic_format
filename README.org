* Introduction

You define a custom binary format via an embedded domain-specific language, and 
serialize-deserialize data with this format via iostreams.

Currently the building blocks of this domain-specific language are:
- primitive formats (currently for integers),
- sequential composition of formats,
- wrapping of structs (the syntax still needs refinement).

* State

This is an early prototype, i.e.
- it almost hasn't been tested
- expect the API to change

* Requirements

The project requires =C++11=, it compiles at least with gcc 4.9.1.

* License

=generic_format= is licensed under [[LICENSE_1_0.txt][BSL 1.0 (Boost Software License 1.0)]]

* Various Ideas
** Organizational
- define a license: MPL, BSL?
- rewrite the introduction of this file
- write a paragraph: why not use boost::spirit/karma?
** Features
- floating point primitives
- strings. Provide various alternatives: fixed-length, zero-terminated, length-data-format, ...
- enums
- sequences: be variadic
- repeated fields
- refine syntax for struct-wrapping
- function to determine the size of a format at compile-time
- support nested structs
- have a look at the [[https://github.com/ztellman/gloss/wiki/Introduction][gloss]] features
- Seriously support endianness. Currently we support it in the naming
  scheme, but then again =uint8_le= and =uint8_be= will certainly be the same.
- what contract do we need for async i/o?
- Allow the format to be saved in a file. This could integrate a flag which
  byte-order has been used, such that files created on a machine are
  automatically created in the native endian format, but files copied from
  another machine can still be loaded.
- Versioning of formats?
- Automatically fill-in serialized types based on the types of the fields,
  if not provided. This is a dangerous feature, and I would only implement it if
  the formats are stored in the header of each file.
** Code Cleanup
- =adapt_struct= -> =struct_format=
- =attribute= => =member_ptr=
- clean up benchmark (especially timing part)
- use more type inference
- naming (especially remove single-letter names)
- remove template argument from adapt_struct
- remove std::tuple dependency
- use =size_t= when appropriate
- clean up the build system. For example I don't like that we force C++11
  upon other people, even on those who are using C++14. Also check if
  installation of the header files works correctly, and other projects can use
  it correcly via =find_package=.
- factor out foreach to iterate over all the fields
- use initializer initialization
- json de/serialization
- add doxygen and a proper documentation
** Optimizations
- verify how gcc and clang compile the code
- perhaps play with inlining
- maybe don't use references for primitive types
- optimization: =adapted_struct=: if no padding and pod, copy memory
