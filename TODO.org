* Various Ideas
** Documentation
- rewrite the introduction of the README file
- write a paragraph: why not use boost::spirit/karma?
- general overview (list the various aspects of the library)
- how to wrap own types
** Philosophical Questions
- or return value, or pass reference, to fill result?
  - or even reduce the data with some function?
** Features
- priorities
  - scopes for placeholders. Within a scope:
    - all nested placeholders will be translated to a unique placeholder
    - within a scope
    - but how can we leak a placeholder, e.g. the 'data_ref', to write visitors
  - remove coupling to vector
    - use visitors instead
    - pointwise visitor
      - hook: pre
      - hook: pointwise
      - hook: post
    - bulk visitor
      - has access to raw reader/writer
    - example visitors
      - see sample arguments for std::copy
      - memcpy
      - custom (e..g. opencv)
- allow serialization to asio buffers
- repeated fields,
  - port strings to this infrastructure
  - replace the state by varargs (even only the arguments which are actually referenced!)
  - deref operator
    - verify reference has been defined before in the format
  - how to "nest" references (e.g. nested structs, all have references)
    - make a variadic kind of generator, which is given as a template argument?
  - disable copy ctor for state
  - also allow reference+constant arithmetic
  - try out with map<int, map<int, int>>
  - we need another argument for read/write methods, a state object
    - the struct can be accessed by placeholders
  - test for overflows!
  - who takes care of the allocation of 'data'?
  - or when the data is simply serialized into a vector
- can we somehow wrap private fields?
- strings: provide alternatives: fixed-length, zero-terminated, length-data-format, ...
- more meaningful error messages
- floating point primitives
- enums
- iterator-like interface
- array-like interface for fixed-length types
- sequences: be variadic
- mapping from one type to the other without intermediate data structure
- keep state, e.g. checksums
- verify header fields, e.g. via integral_constant
- have a look at the [[https://github.com/ztellman/gloss/wiki/Introduction][gloss]] features
- Seriously support endianness. Currently we support it in the naming
  scheme, but then again =uint8_le= and =uint8_be= will certainly be the same.
- Allow the format to be saved in a file. This could integrate a flag which
  byte-order has been used, such that files created on a machine are
  automatically created in the native endian format, but files copied from
  another machine can still be loaded.
- Versioning of formats?
- Automatically fill-in serialized types based on the types of the fields,
  if not provided. This is a dangerous feature, and I would only implement it if
  the formats are stored in the header of each file.
- lookup-indices to seek to position
- json de/serialization
- merge of two files
** Code Cleanup
- extract custom map type (indexed by a Predicate)
- use =std::forward<>...= in reader/writer???
- separate interface and implementation (e.g. helper.hpp)
- search for '...' and check if it can be simplified
- somehow reuse the same code (via visitor pattern?) for
  - write
  - read
  - seek
  - size
  - ...
- move more into base class of ast?
  - e.g. native_type
- generic ast traversal (via ::children)
  - to compute size
  - to compute placeholder_map
- completely factor out size computation
- where to put operator<<? Same namespace? Global namespace?
- in DEBUG builds: fail if buffer overrun in unbounded_memory? (e.g. via some assertions, and DEBUG flags?)
- be less sloppy about move ctors in tests (especially assignments)
- provide default values via initializer lists
- fill in doxygen @author & co
- factor out foreach
- remove type-specific operator() from =raw_reader= and =raw_writer=
- =adapt_struct= -> =struct_format=
- use 'explicit' where appropriate
- named members
- use more initializer syntax
- clean up benchmark (especially timing part)
- use more type inference
- clean up the build system. For example I don't like that we force C++11
  upon other people, even on those who are using C++14. Also check if
  installation of the header files works correctly, and other projects can use
  it correcly via =find_package=.
- add doxygen and a proper high-level documentation
** Missing Documentation
- contract for =raw_reader= and =raw_writer=
** Optimizations
- verify how gcc and clang compile the code
- perhaps play with inlining
- maybe don't use references for primitive types
- optimization: =adapted_struct=: if no padding and pod, copy memory
